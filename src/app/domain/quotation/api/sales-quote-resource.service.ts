/**
 * miles-quotation
 * This service supports creation, calculation and follow-up of sales quotes (price proposals), typically    involving selection/configuration of a vehicle/asset and a choice of finance or rental product.
 *
 * The version of the OpenAPI document: 4.113.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { AllocatedDriverRequest } from '../model/allocated-driver-request';
// @ts-ignore
import { AllocatedDriverResponse } from '../model/allocated-driver-response';
// @ts-ignore
import { AllocatedDriversResponse } from '../model/allocated-drivers-response';
// @ts-ignore
import { AttachedDocument } from '../model/attached-document';
// @ts-ignore
import { CalculateSalesQuoteConfigVehicleRequest } from '../model/calculate-sales-quote-config-vehicle-request';
// @ts-ignore
import { CalculateSalesQuoteRequest } from '../model/calculate-sales-quote-request';
// @ts-ignore
import { CalculateSalesQuoteResponse } from '../model/calculate-sales-quote-response';
// @ts-ignore
import { CalculateSalesQuoteToTargetRequest } from '../model/calculate-sales-quote-to-target-request';
// @ts-ignore
import { CancelSalesQuoteRequest } from '../model/cancel-sales-quote-request';
// @ts-ignore
import { ChangeBrokerContactOnSalesQuoteRequest } from '../model/change-broker-contact-on-sales-quote-request';
// @ts-ignore
import { CoCustomerRequest } from '../model/co-customer-request';
// @ts-ignore
import { CoCustomerResponse } from '../model/co-customer-response';
// @ts-ignore
import { ConfirmSalesQuoteRequest } from '../model/confirm-sales-quote-request';
// @ts-ignore
import { ConfirmSalesQuoteResponse } from '../model/confirm-sales-quote-response';
// @ts-ignore
import { CreateCustomerLinkToSalesQuoteRequest } from '../model/create-customer-link-to-sales-quote-request';
// @ts-ignore
import { CreateDocumentRequest } from '../model/create-document-request';
// @ts-ignore
import { CreateDriverLinkToSalesQuoteRequest } from '../model/create-driver-link-to-sales-quote-request';
// @ts-ignore
import { EditSalesQuoteRequest } from '../model/edit-sales-quote-request';
// @ts-ignore
import { EditSalesQuoteResponse } from '../model/edit-sales-quote-response';
// @ts-ignore
import { ExceptionInfoDTO } from '../model/exception-info-dto';
// @ts-ignore
import { FindAttachedDocumentsResponse } from '../model/find-attached-documents-response';
// @ts-ignore
import { FindAttachedStipulationDocumentsResponse } from '../model/find-attached-stipulation-documents-response';
// @ts-ignore
import { FindAvailableDocumentTemplatesResponse } from '../model/find-available-document-templates-response';
// @ts-ignore
import { FindCoCustomersResponse } from '../model/find-co-customers-response';
// @ts-ignore
import { FindSalesQuotesResponse } from '../model/find-sales-quotes-response';
// @ts-ignore
import { FindShowroomQuotesResponse } from '../model/find-showroom-quotes-response';
// @ts-ignore
import { FindStipulationsResponse } from '../model/find-stipulations-response';
// @ts-ignore
import { FindSuppliersResponse } from '../model/find-suppliers-response';
// @ts-ignore
import { GenerateDocumentRequest } from '../model/generate-document-request';
// @ts-ignore
import { GetSalesQuoteResponse } from '../model/get-sales-quote-response';
// @ts-ignore
import { MailTemplatedMessageContents } from '../model/mail-templated-message-contents';
// @ts-ignore
import { QuotationTemplateResponse } from '../model/quotation-template-response';
// @ts-ignore
import { RentalProfileResponse } from '../model/rental-profile-response';
// @ts-ignore
import { SalesQuotePricingDetails } from '../model/sales-quote-pricing-details';
// @ts-ignore
import { SalesQuoteSignUrl } from '../model/sales-quote-sign-url';
// @ts-ignore
import { SendMailSalesQuoteRequest } from '../model/send-mail-sales-quote-request';
// @ts-ignore
import { UpdateBrokerContactSalesQuoteResponse } from '../model/update-broker-contact-sales-quote-response';
// @ts-ignore
import { UpdateDriverLinkToSalesQuoteRequest } from '../model/update-driver-link-to-sales-quote-request';
// @ts-ignore
import { UpdateSalesQuoteCreatedCustomerResponse } from '../model/update-sales-quote-created-customer-response';
// @ts-ignore
import { UpdateSalesQuoteDriverResponse } from '../model/update-sales-quote-driver-response';
// @ts-ignore
import { UpdateSalesQuoteRequest } from '../model/update-sales-quote-request';
// @ts-ignore
import { UpdateSalesQuoteResponse } from '../model/update-sales-quote-response';
// @ts-ignore
import { UpdateSalesQuoteStatusResponse } from '../model/update-sales-quote-status-response';
// @ts-ignore
import { ValidateSalesQuoteRequest } from '../model/validate-sales-quote-request';
// @ts-ignore
import { ValidateSalesQuoteResponse } from '../model/validate-sales-quote-response';
// @ts-ignore
import { WarningsInfoDTO } from '../model/warnings-info-dto';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class SalesQuoteResourceService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Add a new co-customer to the sales quote
     * This endpoint adds a new co-customer to the sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param coCustomerRequest Co-customer data required to add to the sales quote
     * @param ignoreWarnings Indicates whether warnings should be ignored. If set to true, interactive warnings will be ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addCoCustomerForSalesQuote(salesQuoteId: string, coCustomerRequest: CoCustomerRequest, ignoreWarnings?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CoCustomerResponse>;
    public addCoCustomerForSalesQuote(salesQuoteId: string, coCustomerRequest: CoCustomerRequest, ignoreWarnings?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CoCustomerResponse>>;
    public addCoCustomerForSalesQuote(salesQuoteId: string, coCustomerRequest: CoCustomerRequest, ignoreWarnings?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CoCustomerResponse>>;
    public addCoCustomerForSalesQuote(salesQuoteId: string, coCustomerRequest: CoCustomerRequest, ignoreWarnings?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling addCoCustomerForSalesQuote.');
        }
        if (coCustomerRequest === null || coCustomerRequest === undefined) {
            throw new Error('Required parameter coCustomerRequest was null or undefined when calling addCoCustomerForSalesQuote.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ignoreWarnings !== undefined && ignoreWarnings !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ignoreWarnings, 'ignore_warnings');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/co-customers`;
        return this.httpClient.request<CoCustomerResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: coCustomerRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Attach document to sales quote
     * This endpoint uploads a document for a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param file The file you want to attach
     * @param description The description for the file
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public attachDocument(salesQuoteId: string, file: Blob, description?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AttachedDocument>;
    public attachDocument(salesQuoteId: string, file: Blob, description?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AttachedDocument>>;
    public attachDocument(salesQuoteId: string, file: Blob, description?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AttachedDocument>>;
    public attachDocument(salesQuoteId: string, file: Blob, description?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling attachDocument.');
        }
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling attachDocument.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        localVarUseForm = canConsumeForm;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (file !== undefined) {
            localVarFormParams = localVarFormParams.append('file', <any>file) as any || localVarFormParams;
        }
        if (description !== undefined) {
            localVarFormParams = localVarFormParams.append('description', <any>description) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents`;
        return this.httpClient.request<AttachedDocument>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Calculate sales quote
     * This endpoint calculates a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param calculateSalesQuoteRequest Data required to calculate a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public calculateSalesQuote(salesQuoteId: string, calculateSalesQuoteRequest?: CalculateSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CalculateSalesQuoteResponse>;
    public calculateSalesQuote(salesQuoteId: string, calculateSalesQuoteRequest?: CalculateSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CalculateSalesQuoteResponse>>;
    public calculateSalesQuote(salesQuoteId: string, calculateSalesQuoteRequest?: CalculateSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CalculateSalesQuoteResponse>>;
    public calculateSalesQuote(salesQuoteId: string, calculateSalesQuoteRequest?: CalculateSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling calculateSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/calculations`;
        return this.httpClient.request<CalculateSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: calculateSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update config vehicle and calculate a sales quote
     * This endpoint updates config vehicle data and calculates a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param calculateSalesQuoteConfigVehicleRequest Data required to calculate a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public calculateSalesQuoteForConfigVehicle(salesQuoteId: string, calculateSalesQuoteConfigVehicleRequest: CalculateSalesQuoteConfigVehicleRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CalculateSalesQuoteResponse>;
    public calculateSalesQuoteForConfigVehicle(salesQuoteId: string, calculateSalesQuoteConfigVehicleRequest: CalculateSalesQuoteConfigVehicleRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CalculateSalesQuoteResponse>>;
    public calculateSalesQuoteForConfigVehicle(salesQuoteId: string, calculateSalesQuoteConfigVehicleRequest: CalculateSalesQuoteConfigVehicleRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CalculateSalesQuoteResponse>>;
    public calculateSalesQuoteForConfigVehicle(salesQuoteId: string, calculateSalesQuoteConfigVehicleRequest: CalculateSalesQuoteConfigVehicleRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling calculateSalesQuoteForConfigVehicle.');
        }
        if (calculateSalesQuoteConfigVehicleRequest === null || calculateSalesQuoteConfigVehicleRequest === undefined) {
            throw new Error('Required parameter calculateSalesQuoteConfigVehicleRequest was null or undefined when calling calculateSalesQuoteForConfigVehicle.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/calculations/vehicles`;
        return this.httpClient.request<CalculateSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: calculateSalesQuoteConfigVehicleRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Calculate sales quote to target
     * This endpoint calculates a sales quote to target a specified lease price by modifing another attribute.
     * @param salesQuoteId ID of the sales quote
     * @param calculateSalesQuoteToTargetRequest Data required to calculate a sales quote to target, if the properties targetPrice and downPayment are null, we will take the budget as targetPrice
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public calculateSalesQuoteToTarget(salesQuoteId: string, calculateSalesQuoteToTargetRequest: CalculateSalesQuoteToTargetRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CalculateSalesQuoteResponse>;
    public calculateSalesQuoteToTarget(salesQuoteId: string, calculateSalesQuoteToTargetRequest: CalculateSalesQuoteToTargetRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CalculateSalesQuoteResponse>>;
    public calculateSalesQuoteToTarget(salesQuoteId: string, calculateSalesQuoteToTargetRequest: CalculateSalesQuoteToTargetRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CalculateSalesQuoteResponse>>;
    public calculateSalesQuoteToTarget(salesQuoteId: string, calculateSalesQuoteToTargetRequest: CalculateSalesQuoteToTargetRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling calculateSalesQuoteToTarget.');
        }
        if (calculateSalesQuoteToTargetRequest === null || calculateSalesQuoteToTargetRequest === undefined) {
            throw new Error('Required parameter calculateSalesQuoteToTargetRequest was null or undefined when calling calculateSalesQuoteToTarget.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/calculations-to-target`;
        return this.httpClient.request<CalculateSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: calculateSalesQuoteToTargetRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel sales quote
     * This endpoint cancels a sales quote.Deprecated since 2023-08-10 and version 4.93.0 in favor of the &#x60;POST /{sales_quote_id}/cancellations&#x60; endpoint
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @deprecated
     */
    public cancelSalesQuote(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteStatusResponse>;
    public cancelSalesQuote(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteStatusResponse>>;
    public cancelSalesQuote(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteStatusResponse>>;
    public cancelSalesQuote(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling cancelSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/cancellations`;
        return this.httpClient.request<UpdateSalesQuoteStatusResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel sales quote
     * This endpoint cancels a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param cancelSalesQuoteRequest Data required to cancel a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancellationOfSalesQuote(salesQuoteId: string, cancelSalesQuoteRequest?: CancelSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteStatusResponse>;
    public cancellationOfSalesQuote(salesQuoteId: string, cancelSalesQuoteRequest?: CancelSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteStatusResponse>>;
    public cancellationOfSalesQuote(salesQuoteId: string, cancelSalesQuoteRequest?: CancelSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteStatusResponse>>;
    public cancellationOfSalesQuote(salesQuoteId: string, cancelSalesQuoteRequest?: CancelSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling cancellationOfSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/cancellations`;
        return this.httpClient.request<UpdateSalesQuoteStatusResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: cancelSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Confirm sales quote
     * This endpoint confirms a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param ignoreWarnings Indicates whether warnings should be ignored. If set to true, interactive warnings will be ignored.
     * @param confirmSalesQuoteRequest Data required to confirm a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public confirmSalesQuote(salesQuoteId: string, ignoreWarnings?: boolean, confirmSalesQuoteRequest?: ConfirmSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ConfirmSalesQuoteResponse>;
    public confirmSalesQuote(salesQuoteId: string, ignoreWarnings?: boolean, confirmSalesQuoteRequest?: ConfirmSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConfirmSalesQuoteResponse>>;
    public confirmSalesQuote(salesQuoteId: string, ignoreWarnings?: boolean, confirmSalesQuoteRequest?: ConfirmSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConfirmSalesQuoteResponse>>;
    public confirmSalesQuote(salesQuoteId: string, ignoreWarnings?: boolean, confirmSalesQuoteRequest?: ConfirmSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling confirmSalesQuote.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ignoreWarnings !== undefined && ignoreWarnings !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ignoreWarnings, 'ignore_warnings');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/confirmations`;
        return this.httpClient.request<ConfirmSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: confirmSalesQuoteRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create an allocated driver
     * This endpoint creates an allocated driver on a quote.
     * @param salesQuoteId ID of the sales quote
     * @param allocatedDriverRequest Data required to create the allocated driver
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AllocatedDriversResponse>;
    public createAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AllocatedDriversResponse>>;
    public createAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AllocatedDriversResponse>>;
    public createAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling createAllocatedDriver.');
        }
        if (allocatedDriverRequest === null || allocatedDriverRequest === undefined) {
            throw new Error('Required parameter allocatedDriverRequest was null or undefined when calling createAllocatedDriver.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/allocated-driver`;
        return this.httpClient.request<AllocatedDriversResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: allocatedDriverRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a customer and immediately afterwards update an existing sales-quote with the created customer
     * This endpoint will create a customer and immediately afterwards update an existing sales-quote with the created customer. The sales-quote should already exist, if it doesn\&#39;t no customer will be created. To update the sales-quote with an already existing customer use: PUT /sales-quotes/{sales_quote_id} with the correct customerId in the request.
     * @param salesQuoteId ID of the sales quote to update
     * @param createCustomerLinkToSalesQuoteRequest Request data to create the customer
     * @param ignoreWarnings Indicates whether warnings should be ignored. If set to true, interactive warnings will be ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCustomerAndLinkToSalesQuote(salesQuoteId: string, createCustomerLinkToSalesQuoteRequest: CreateCustomerLinkToSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteCreatedCustomerResponse>;
    public createCustomerAndLinkToSalesQuote(salesQuoteId: string, createCustomerLinkToSalesQuoteRequest: CreateCustomerLinkToSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteCreatedCustomerResponse>>;
    public createCustomerAndLinkToSalesQuote(salesQuoteId: string, createCustomerLinkToSalesQuoteRequest: CreateCustomerLinkToSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteCreatedCustomerResponse>>;
    public createCustomerAndLinkToSalesQuote(salesQuoteId: string, createCustomerLinkToSalesQuoteRequest: CreateCustomerLinkToSalesQuoteRequest, ignoreWarnings?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling createCustomerAndLinkToSalesQuote.');
        }
        if (createCustomerLinkToSalesQuoteRequest === null || createCustomerLinkToSalesQuoteRequest === undefined) {
            throw new Error('Required parameter createCustomerLinkToSalesQuoteRequest was null or undefined when calling createCustomerAndLinkToSalesQuote.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ignoreWarnings !== undefined && ignoreWarnings !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ignoreWarnings, 'ignore_warnings');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/customers`;
        return this.httpClient.request<UpdateSalesQuoteCreatedCustomerResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createCustomerLinkToSalesQuoteRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create document for a sales quote
     * This endpoint creates a document for a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param createDocumentRequest Data required to create the document
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocument(salesQuoteId: string, createDocumentRequest: CreateDocumentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<Blob>;
    public createDocument(salesQuoteId: string, createDocumentRequest: CreateDocumentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Blob>>;
    public createDocument(salesQuoteId: string, createDocumentRequest: CreateDocumentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Blob>>;
    public createDocument(salesQuoteId: string, createDocumentRequest: CreateDocumentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling createDocument.');
        }
        if (createDocumentRequest === null || createDocumentRequest === undefined) {
            throw new Error('Required parameter createDocumentRequest was null or undefined when calling createDocument.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/octet-stream'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents/actions/creations`;
        return this.httpClient.request('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createDocumentRequest,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a driver and links him/her to the sales quote
     * This endpoint creates a new driver and links him/her to the sales quote of which the ID is given.
     * @param salesQuoteId ID of the sales quote
     * @param createDriverLinkToSalesQuoteRequest Driver data required to add to the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDriverAndLinkToSalesQuote(salesQuoteId: string, createDriverLinkToSalesQuoteRequest: CreateDriverLinkToSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteDriverResponse>;
    public createDriverAndLinkToSalesQuote(salesQuoteId: string, createDriverLinkToSalesQuoteRequest: CreateDriverLinkToSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteDriverResponse>>;
    public createDriverAndLinkToSalesQuote(salesQuoteId: string, createDriverLinkToSalesQuoteRequest: CreateDriverLinkToSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteDriverResponse>>;
    public createDriverAndLinkToSalesQuote(salesQuoteId: string, createDriverLinkToSalesQuoteRequest: CreateDriverLinkToSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling createDriverAndLinkToSalesQuote.');
        }
        if (createDriverLinkToSalesQuoteRequest === null || createDriverLinkToSalesQuoteRequest === undefined) {
            throw new Error('Required parameter createDriverLinkToSalesQuoteRequest was null or undefined when calling createDriverAndLinkToSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/drivers`;
        return this.httpClient.request<UpdateSalesQuoteDriverResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createDriverLinkToSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an allocated driver
     * This endpoint deletes an allocated driver from a quote.
     * @param salesQuoteId ID of the sales quote
     * @param contactId ID of the contact
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAllocatedDriver(salesQuoteId: string, contactId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deleteAllocatedDriver(salesQuoteId: string, contactId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deleteAllocatedDriver(salesQuoteId: string, contactId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deleteAllocatedDriver(salesQuoteId: string, contactId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling deleteAllocatedDriver.');
        }
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling deleteAllocatedDriver.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/allocated-driver/${this.configuration.encodeParam({name: "contactId", value: contactId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete document attached to sales quote
     * This endpoint deletes a document attached to a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param documentId ID of the document
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deleteAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deleteAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deleteAttachedDocument(salesQuoteId: string, documentId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling deleteAttachedDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteAttachedDocument.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents/${this.configuration.encodeParam({name: "documentId", value: documentId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit sales quote
     * This endpoint edits a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param editSalesQuoteRequest Data required to edit a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editSalesQuote(salesQuoteId: string, editSalesQuoteRequest?: EditSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EditSalesQuoteResponse>;
    public editSalesQuote(salesQuoteId: string, editSalesQuoteRequest?: EditSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EditSalesQuoteResponse>>;
    public editSalesQuote(salesQuoteId: string, editSalesQuoteRequest?: EditSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EditSalesQuoteResponse>>;
    public editSalesQuote(salesQuoteId: string, editSalesQuoteRequest?: EditSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling editSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/edits`;
        return this.httpClient.request<EditSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: editSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find documents attached to sales quote
     * This endpoint retrieves a list of all documents attached to a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param statusId ID(s) of the document status(es) (enumeration)
     * @param documentTemplateId ID(s) of the document template(es)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAttachedDocuments(salesQuoteId: string, statusId?: Set<string>, documentTemplateId?: Set<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindAttachedDocumentsResponse>;
    public findAttachedDocuments(salesQuoteId: string, statusId?: Set<string>, documentTemplateId?: Set<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindAttachedDocumentsResponse>>;
    public findAttachedDocuments(salesQuoteId: string, statusId?: Set<string>, documentTemplateId?: Set<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindAttachedDocumentsResponse>>;
    public findAttachedDocuments(salesQuoteId: string, statusId?: Set<string>, documentTemplateId?: Set<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findAttachedDocuments.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (statusId) {
            statusId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status_id');
            })
        }
        if (documentTemplateId) {
            documentTemplateId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'document_template_id');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents`;
        return this.httpClient.request<FindAttachedDocumentsResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find co-customers of a sales quote
     * This endpoint retrieves the co-customers linked to a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCoCustomers(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindCoCustomersResponse>;
    public findCoCustomers(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindCoCustomersResponse>>;
    public findCoCustomers(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindCoCustomersResponse>>;
    public findCoCustomers(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findCoCustomers.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/co-customers`;
        return this.httpClient.request<FindCoCustomersResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find document templates for sales quote
     * This endpoint retrieves a list of document templates allowed for the given quote.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findDocumentTemplates(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindAvailableDocumentTemplatesResponse>;
    public findDocumentTemplates(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindAvailableDocumentTemplatesResponse>>;
    public findDocumentTemplates(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindAvailableDocumentTemplatesResponse>>;
    public findDocumentTemplates(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findDocumentTemplates.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/document-templates`;
        return this.httpClient.request<FindAvailableDocumentTemplatesResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find sales quotes
     * This endpoint retrieves a list of sales quotes.It can be used with a search query using the properties that can be found in the description of the query parameter search_query.It accepts multiple keywords separated by spaces, except for queries with only one character or the !, % and ^ wildcards.An example for a search query is \&#39;11598 A1\&#39;: a search will be performed to find a match or partial match for \&#39;11598\&#39; or \&#39;A1\&#39; on the attributes.
     * @param count The maximum number of elements to be returned
     * @param offset The number of elements to skip before returning the requested list of elements
     * @param sortBy List of order clauses in which the elements will be returned, deprecated since 2022-09-06 and version 1.184.0 in favor of sorting
     * @param sorting List of order clauses in which the elements will be returned
     * @param salesQuoteId ID(s) of the sales quote(s)
     * @param brokerContactId ID(s) of the broker contact(s)
     * @param brokerCompanyId ID(s) of the broker company(ies), only useful in case of broker/dealer users
     * @param quoteStatus ID(s) of the sales quote status(es)
     * @param vehicleCategory ID(s) of the vehicle category(ies)
     * @param driverId ID(s) of the driver(s)
     * @param customerId ID(s) of the customer(s)
     * @param quotationTemplateId ID(s) of the quotation template(s)
     * @param mobilityPlanId ID(s) of the mobility plan(s)
     * @param includeVehicleConfigurationOptions Indicates whether the response should include the vehicle configuration options
     * @param vehicleOptionTypeGroupId ID(s) of the vehicle option type group(s)
     * @param creationDateTo The date until which the created quote is available, specified date included (ex: creation_date_to&#x3D;2023-04-27)
     * @param creationDateFrom The date from which the created quote is available, specified date included (ex: creation_date_from&#x3D;2023-04-27)
     * @param reference The reference of the sales quote
     * @param vehicleModelName The model name of the vehicle
     * @param dynamicAttributeFilters The dynamic attributes to filter on
     * @param searchQuery NOTICE THIS WILL ONLY WORK FOR POSTGRES ODS By filling in this property you can do a back-end search
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSalesQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, salesQuoteId?: Set<string>, brokerContactId?: Set<string>, brokerCompanyId?: Set<string>, quoteStatus?: Set<string>, vehicleCategory?: Set<string>, driverId?: Set<string>, customerId?: Set<string>, quotationTemplateId?: Set<string>, mobilityPlanId?: Set<string>, includeVehicleConfigurationOptions?: boolean, vehicleOptionTypeGroupId?: Set<string>, creationDateTo?: string, creationDateFrom?: string, reference?: string, vehicleModelName?: string, dynamicAttributeFilters?: Set<string>, searchQuery?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindSalesQuotesResponse>;
    public findSalesQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, salesQuoteId?: Set<string>, brokerContactId?: Set<string>, brokerCompanyId?: Set<string>, quoteStatus?: Set<string>, vehicleCategory?: Set<string>, driverId?: Set<string>, customerId?: Set<string>, quotationTemplateId?: Set<string>, mobilityPlanId?: Set<string>, includeVehicleConfigurationOptions?: boolean, vehicleOptionTypeGroupId?: Set<string>, creationDateTo?: string, creationDateFrom?: string, reference?: string, vehicleModelName?: string, dynamicAttributeFilters?: Set<string>, searchQuery?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindSalesQuotesResponse>>;
    public findSalesQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, salesQuoteId?: Set<string>, brokerContactId?: Set<string>, brokerCompanyId?: Set<string>, quoteStatus?: Set<string>, vehicleCategory?: Set<string>, driverId?: Set<string>, customerId?: Set<string>, quotationTemplateId?: Set<string>, mobilityPlanId?: Set<string>, includeVehicleConfigurationOptions?: boolean, vehicleOptionTypeGroupId?: Set<string>, creationDateTo?: string, creationDateFrom?: string, reference?: string, vehicleModelName?: string, dynamicAttributeFilters?: Set<string>, searchQuery?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindSalesQuotesResponse>>;
    public findSalesQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, salesQuoteId?: Set<string>, brokerContactId?: Set<string>, brokerCompanyId?: Set<string>, quoteStatus?: Set<string>, vehicleCategory?: Set<string>, driverId?: Set<string>, customerId?: Set<string>, quotationTemplateId?: Set<string>, mobilityPlanId?: Set<string>, includeVehicleConfigurationOptions?: boolean, vehicleOptionTypeGroupId?: Set<string>, creationDateTo?: string, creationDateFrom?: string, reference?: string, vehicleModelName?: string, dynamicAttributeFilters?: Set<string>, searchQuery?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (count !== undefined && count !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>count, 'count');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sort_by');
            })
        }
        if (sorting) {
            sorting.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sorting');
            })
        }
        if (salesQuoteId) {
            salesQuoteId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sales_quote_id');
            })
        }
        if (brokerContactId) {
            brokerContactId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'broker_contact_id');
            })
        }
        if (brokerCompanyId) {
            brokerCompanyId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'broker_company_id');
            })
        }
        if (quoteStatus) {
            quoteStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'quote_status');
            })
        }
        if (vehicleCategory) {
            vehicleCategory.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'vehicle_category');
            })
        }
        if (driverId) {
            driverId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'driver_id');
            })
        }
        if (customerId) {
            customerId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'customer_id');
            })
        }
        if (quotationTemplateId) {
            quotationTemplateId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'quotation_template_id');
            })
        }
        if (mobilityPlanId) {
            mobilityPlanId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'mobility_plan_id');
            })
        }
        if (includeVehicleConfigurationOptions !== undefined && includeVehicleConfigurationOptions !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>includeVehicleConfigurationOptions, 'include_vehicle_configuration_options');
        }
        if (vehicleOptionTypeGroupId) {
            vehicleOptionTypeGroupId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'vehicle_option_type_group_id');
            })
        }
        if (creationDateTo !== undefined && creationDateTo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>creationDateTo, 'creation_date_to');
        }
        if (creationDateFrom !== undefined && creationDateFrom !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>creationDateFrom, 'creation_date_from');
        }
        if (reference !== undefined && reference !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>reference, 'reference');
        }
        if (vehicleModelName !== undefined && vehicleModelName !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vehicleModelName, 'vehicle_model_name');
        }
        if (dynamicAttributeFilters) {
            dynamicAttributeFilters.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dynamic_attribute_filters');
            })
        }
        if (searchQuery !== undefined && searchQuery !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchQuery, 'search_query');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes`;
        return this.httpClient.request<FindSalesQuotesResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find showroom quotes
     * This endpoint retrieves a list of showroom quotes. Additional information on these quotes can be retrieved by calling the GET /sales-quotes/{id} endpoint.
     * @param count The maximum number of elements to be returned
     * @param offset The number of elements to skip before returning the requested list of elements
     * @param sortBy List of order clauses in which the elements will be returned, deprecated since 2022-09-06 and version 1.184.0 in favor of sorting
     * @param sorting List of order clauses in which the elements will be returned
     * @param validOn The date on which the showroom quote should be valid (not expired)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findShowroomQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, validOn?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindShowroomQuotesResponse>;
    public findShowroomQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, validOn?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindShowroomQuotesResponse>>;
    public findShowroomQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, validOn?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindShowroomQuotesResponse>>;
    public findShowroomQuotes(count?: number, offset?: number, sortBy?: Array<string>, sorting?: Array<string>, validOn?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (count !== undefined && count !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>count, 'count');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sort_by');
            })
        }
        if (sorting) {
            sorting.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sorting');
            })
        }
        if (validOn !== undefined && validOn !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>validOn, 'valid_on');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/showroom-quotes`;
        return this.httpClient.request<FindShowroomQuotesResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find stipulation documents
     * This endpoint retrieves the documents attached to a sales quote stipulation.
     * @param salesQuoteId ID of the sales quote
     * @param stipulationId ID of the sales quote stipulation
     * @param count The maximum number of stipulation documents to be displayed in the response
     * @param offset The number of stipulation documents to exclude before returning the collection
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findStipulationDocuments(salesQuoteId: string, stipulationId: string, count?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindAttachedStipulationDocumentsResponse>;
    public findStipulationDocuments(salesQuoteId: string, stipulationId: string, count?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindAttachedStipulationDocumentsResponse>>;
    public findStipulationDocuments(salesQuoteId: string, stipulationId: string, count?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindAttachedStipulationDocumentsResponse>>;
    public findStipulationDocuments(salesQuoteId: string, stipulationId: string, count?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findStipulationDocuments.');
        }
        if (stipulationId === null || stipulationId === undefined) {
            throw new Error('Required parameter stipulationId was null or undefined when calling findStipulationDocuments.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (count !== undefined && count !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>count, 'count');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/stipulations/${this.configuration.encodeParam({name: "stipulationId", value: stipulationId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents`;
        return this.httpClient.request<FindAttachedStipulationDocumentsResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find sales quote stipulations
     * This endpoint retrieves the stipulations for a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param count The maximum number of stipulations to be displayed in the response
     * @param offset The number of stipulations to exclude before returning the collection
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findStipulations(salesQuoteId: string, count?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindStipulationsResponse>;
    public findStipulations(salesQuoteId: string, count?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindStipulationsResponse>>;
    public findStipulations(salesQuoteId: string, count?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindStipulationsResponse>>;
    public findStipulations(salesQuoteId: string, count?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findStipulations.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (count !== undefined && count !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>count, 'count');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/stipulations`;
        return this.httpClient.request<FindStipulationsResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find suppliers for sales quote
     * This endpoint retrieves a list of suppliers for a sales quote based on the make.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSuppliers(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FindSuppliersResponse>;
    public findSuppliers(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FindSuppliersResponse>>;
    public findSuppliers(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FindSuppliersResponse>>;
    public findSuppliers(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling findSuppliers.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/suppliers`;
        return this.httpClient.request<FindSuppliersResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate document for a sales quote
     * This endpoint generates a document for a sales quote in the backend, but will not download it.
     * @param salesQuoteId ID of the sales quote
     * @param generateDocumentRequest Data required to generate the document
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public generateDocument(salesQuoteId: string, generateDocumentRequest: GenerateDocumentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AttachedDocument>;
    public generateDocument(salesQuoteId: string, generateDocumentRequest: GenerateDocumentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AttachedDocument>>;
    public generateDocument(salesQuoteId: string, generateDocumentRequest: GenerateDocumentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AttachedDocument>>;
    public generateDocument(salesQuoteId: string, generateDocumentRequest: GenerateDocumentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling generateDocument.');
        }
        if (generateDocumentRequest === null || generateDocumentRequest === undefined) {
            throw new Error('Required parameter generateDocumentRequest was null or undefined when calling generateDocument.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents/generations`;
        return this.httpClient.request<AttachedDocument>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: generateDocumentRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an allocated driver
     * This endpoint retrieves an allocated driver for the authenticated driver, based on a sales quote ID and driver ID.
     * @param salesQuoteId ID of the sales quote
     * @param driverId ID of the driver
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllocatedDriver(salesQuoteId: string, driverId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AllocatedDriverResponse>;
    public getAllocatedDriver(salesQuoteId: string, driverId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AllocatedDriverResponse>>;
    public getAllocatedDriver(salesQuoteId: string, driverId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AllocatedDriverResponse>>;
    public getAllocatedDriver(salesQuoteId: string, driverId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getAllocatedDriver.');
        }
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling getAllocatedDriver.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/allocated-drivers/${this.configuration.encodeParam({name: "driverId", value: driverId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<AllocatedDriverResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get list of allocated drivers
     * This endpoint retrieves a list of allocated drivers for the authenticated driver, based on a sales quote ID.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllocatedDrivers(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AllocatedDriversResponse>;
    public getAllocatedDrivers(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AllocatedDriversResponse>>;
    public getAllocatedDrivers(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AllocatedDriversResponse>>;
    public getAllocatedDrivers(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getAllocatedDrivers.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/allocated-drivers`;
        return this.httpClient.request<AllocatedDriversResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get document attached to sales quote
     * This endpoint downloads a document attached to a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param documentId ID of the document
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<Blob>;
    public getAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Blob>>;
    public getAttachedDocument(salesQuoteId: string, documentId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Blob>>;
    public getAttachedDocument(salesQuoteId: string, documentId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/octet-stream', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getAttachedDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getAttachedDocument.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/octet-stream'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/documents/${this.configuration.encodeParam({name: "documentId", value: documentId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find available quotation templates for a sales quote
     * This endpoint retrieves a list of quotation templates for a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param includeObjectInformation Use \&#39;include_additional_content\&#39; instead.
     * @param includeAdditionalContent Boolean to indicate if additional additionalContent attribute is fetched.
     * @param additionalContentKey The key(s) on which the additional content must be filtered, this will be ignored if \&#39;include_additional_content\&#39; is false.
     * @param contractTypeId The contract types on which quotation templates must be filtered
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAvailableQuotationTemplatesForSalesQuote(salesQuoteId: string, includeObjectInformation?: boolean, includeAdditionalContent?: boolean, additionalContentKey?: Set<string>, contractTypeId?: Set<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QuotationTemplateResponse>;
    public getAvailableQuotationTemplatesForSalesQuote(salesQuoteId: string, includeObjectInformation?: boolean, includeAdditionalContent?: boolean, additionalContentKey?: Set<string>, contractTypeId?: Set<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QuotationTemplateResponse>>;
    public getAvailableQuotationTemplatesForSalesQuote(salesQuoteId: string, includeObjectInformation?: boolean, includeAdditionalContent?: boolean, additionalContentKey?: Set<string>, contractTypeId?: Set<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QuotationTemplateResponse>>;
    public getAvailableQuotationTemplatesForSalesQuote(salesQuoteId: string, includeObjectInformation?: boolean, includeAdditionalContent?: boolean, additionalContentKey?: Set<string>, contractTypeId?: Set<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getAvailableQuotationTemplatesForSalesQuote.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (includeObjectInformation !== undefined && includeObjectInformation !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>includeObjectInformation, 'include_object_information');
        }
        if (includeAdditionalContent !== undefined && includeAdditionalContent !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>includeAdditionalContent, 'include_additional_content');
        }
        if (additionalContentKey) {
            additionalContentKey.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'additional_content_key');
            })
        }
        if (contractTypeId) {
            contractTypeId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contract_type_id');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/quotation-templates`;
        return this.httpClient.request<QuotationTemplateResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get rental profile
     * This endpoint retrieves the rental profile for a certain sales quote. The rental profile can be defined on quote product and on quote service level. Use the quote service ID filter to show the rental profile for one component.
     * @param salesQuoteId ID of the sales quote
     * @param quoteServiceId ID of the quote service component
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRentalProfile(salesQuoteId: string, quoteServiceId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RentalProfileResponse>;
    public getRentalProfile(salesQuoteId: string, quoteServiceId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RentalProfileResponse>>;
    public getRentalProfile(salesQuoteId: string, quoteServiceId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RentalProfileResponse>>;
    public getRentalProfile(salesQuoteId: string, quoteServiceId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getRentalProfile.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (quoteServiceId !== undefined && quoteServiceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>quoteServiceId, 'quote_service_id');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/rental-profiles`;
        return this.httpClient.request<RentalProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get sales quote
     * This endpoint retrieves a sales quote by ID.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSalesQuote(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GetSalesQuoteResponse>;
    public getSalesQuote(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GetSalesQuoteResponse>>;
    public getSalesQuote(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GetSalesQuoteResponse>>;
    public getSalesQuote(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<GetSalesQuoteResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get pricing details
     * This endpoint retrieves the pricing details of a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSalesQuotePricingDetails(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SalesQuotePricingDetails>;
    public getSalesQuotePricingDetails(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SalesQuotePricingDetails>>;
    public getSalesQuotePricingDetails(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SalesQuotePricingDetails>>;
    public getSalesQuotePricingDetails(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getSalesQuotePricingDetails.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/pricing-details`;
        return this.httpClient.request<SalesQuotePricingDetails>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create sign URL for sales quotes
     * This endpoint creates the sign URL for a set of sales quotes.
     * @param salesQuoteId ID(s) of the sales quote(s)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSalesQuoteSignUrl(salesQuoteId: Set<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SalesQuoteSignUrl>;
    public getSalesQuoteSignUrl(salesQuoteId: Set<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SalesQuoteSignUrl>>;
    public getSalesQuoteSignUrl(salesQuoteId: Set<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SalesQuoteSignUrl>>;
    public getSalesQuoteSignUrl(salesQuoteId: Set<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getSalesQuoteSignUrl.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (salesQuoteId) {
            salesQuoteId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sales_quote_id');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/sign-urls`;
        return this.httpClient.request<SalesQuoteSignUrl>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate mail content to send a mail for a sales quote
     * This endpoint will generate the necessary templated message contents for a sales quote that needs to be sent by mail.
     * @param salesQuoteId ID of the sales quote
     * @param mailSubjectTemplateId The text template ID that should be used to generate the mail subject
     * @param mailBodyTemplateId The text template ID that should be used to generate the mail body
     * @param language The ISO 639-1 or ISO 639-2 code of the language in which the mail subject and body should be generated. If not passed the language of the logged-in user will be used.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTemplatedMessageContents(salesQuoteId: string, mailSubjectTemplateId: string, mailBodyTemplateId: string, language?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MailTemplatedMessageContents>;
    public getTemplatedMessageContents(salesQuoteId: string, mailSubjectTemplateId: string, mailBodyTemplateId: string, language?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MailTemplatedMessageContents>>;
    public getTemplatedMessageContents(salesQuoteId: string, mailSubjectTemplateId: string, mailBodyTemplateId: string, language?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MailTemplatedMessageContents>>;
    public getTemplatedMessageContents(salesQuoteId: string, mailSubjectTemplateId: string, mailBodyTemplateId: string, language?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling getTemplatedMessageContents.');
        }
        if (mailSubjectTemplateId === null || mailSubjectTemplateId === undefined) {
            throw new Error('Required parameter mailSubjectTemplateId was null or undefined when calling getTemplatedMessageContents.');
        }
        if (mailBodyTemplateId === null || mailBodyTemplateId === undefined) {
            throw new Error('Required parameter mailBodyTemplateId was null or undefined when calling getTemplatedMessageContents.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (mailSubjectTemplateId !== undefined && mailSubjectTemplateId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mailSubjectTemplateId, 'mail_subject_template_id');
        }
        if (mailBodyTemplateId !== undefined && mailBodyTemplateId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mailBodyTemplateId, 'mail_body_template_id');
        }
        if (language !== undefined && language !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>language, 'language');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/templated-message-contents`;
        return this.httpClient.request<MailTemplatedMessageContents>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Link driver to the sales quote
     * This endpoint links the driver to the sales quote.
     * @param salesQuoteId ID of the sales quote to update
     * @param updateDriverLinkToSalesQuoteRequest Data required to change broker contact on a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public linkDriverToSalesQuote(salesQuoteId: string, updateDriverLinkToSalesQuoteRequest: UpdateDriverLinkToSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteDriverResponse>;
    public linkDriverToSalesQuote(salesQuoteId: string, updateDriverLinkToSalesQuoteRequest: UpdateDriverLinkToSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteDriverResponse>>;
    public linkDriverToSalesQuote(salesQuoteId: string, updateDriverLinkToSalesQuoteRequest: UpdateDriverLinkToSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteDriverResponse>>;
    public linkDriverToSalesQuote(salesQuoteId: string, updateDriverLinkToSalesQuoteRequest: UpdateDriverLinkToSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling linkDriverToSalesQuote.');
        }
        if (updateDriverLinkToSalesQuoteRequest === null || updateDriverLinkToSalesQuoteRequest === undefined) {
            throw new Error('Required parameter updateDriverLinkToSalesQuoteRequest was null or undefined when calling linkDriverToSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/drivers`;
        return this.httpClient.request<UpdateSalesQuoteDriverResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: updateDriverLinkToSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Propose sales quote
     * This endpoint proposes a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public proposeSalesQuote(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteStatusResponse>;
    public proposeSalesQuote(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteStatusResponse>>;
    public proposeSalesQuote(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteStatusResponse>>;
    public proposeSalesQuote(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling proposeSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/proposals`;
        return this.httpClient.request<UpdateSalesQuoteStatusResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reject sales quote
     * This endpoint rejects a sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rejectSalesQuote(salesQuoteId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteStatusResponse>;
    public rejectSalesQuote(salesQuoteId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteStatusResponse>>;
    public rejectSalesQuote(salesQuoteId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteStatusResponse>>;
    public rejectSalesQuote(salesQuoteId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling rejectSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/actions/rejections`;
        return this.httpClient.request<UpdateSalesQuoteStatusResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove an existing co-customer from the sales quote
     * This endpoint removes an existing co-customer from the sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param customerId ID of the customer
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeCoCustomerForSalesQuote(salesQuoteId: string, customerId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public removeCoCustomerForSalesQuote(salesQuoteId: string, customerId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public removeCoCustomerForSalesQuote(salesQuoteId: string, customerId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public removeCoCustomerForSalesQuote(salesQuoteId: string, customerId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling removeCoCustomerForSalesQuote.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeCoCustomerForSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/co-customers/${this.configuration.encodeParam({name: "customerId", value: customerId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send an email for the sales quote
     * This endpoint will send an email related to the requested sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param sendMailSalesQuoteRequest Data required to send the mail
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendMailSalesQuote(salesQuoteId: string, sendMailSalesQuoteRequest: SendMailSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public sendMailSalesQuote(salesQuoteId: string, sendMailSalesQuoteRequest: SendMailSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public sendMailSalesQuote(salesQuoteId: string, sendMailSalesQuoteRequest: SendMailSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public sendMailSalesQuote(salesQuoteId: string, sendMailSalesQuoteRequest: SendMailSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling sendMailSalesQuote.');
        }
        if (sendMailSalesQuoteRequest === null || sendMailSalesQuoteRequest === undefined) {
            throw new Error('Required parameter sendMailSalesQuoteRequest was null or undefined when calling sendMailSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/sending-sales-quotes`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: sendMailSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unlink the driver from the sales quote
     * This endpoint unlinks the driver from the sales quote.
     * @param salesQuoteId ID of the sales quote to update
     * @param driverId Contact ID of the driver to be unlinked from the sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unlinkDriverFromSalesQuote(salesQuoteId: string, driverId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public unlinkDriverFromSalesQuote(salesQuoteId: string, driverId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public unlinkDriverFromSalesQuote(salesQuoteId: string, driverId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public unlinkDriverFromSalesQuote(salesQuoteId: string, driverId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling unlinkDriverFromSalesQuote.');
        }
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling unlinkDriverFromSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/drivers/${this.configuration.encodeParam({name: "driverId", value: driverId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update an allocated driver
     * This endpoint updates an allocated driver on a quote.
     * @param salesQuoteId ID of the sales quote
     * @param allocatedDriverRequest Data required to update the allocated driver
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AllocatedDriversResponse>;
    public updateAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AllocatedDriversResponse>>;
    public updateAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AllocatedDriversResponse>>;
    public updateAllocatedDriver(salesQuoteId: string, allocatedDriverRequest: AllocatedDriverRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling updateAllocatedDriver.');
        }
        if (allocatedDriverRequest === null || allocatedDriverRequest === undefined) {
            throw new Error('Required parameter allocatedDriverRequest was null or undefined when calling updateAllocatedDriver.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/allocated-driver`;
        return this.httpClient.request<AllocatedDriversResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: allocatedDriverRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change the broker contact on the sales quote
     * This endpoint changes the broker contact on the sales quote.
     * @param salesQuoteId ID of the sales quote
     * @param changeBrokerContactOnSalesQuoteRequest Data required to change broker contact on a sales quote
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateBrokerContactSalesQuote(salesQuoteId: string, changeBrokerContactOnSalesQuoteRequest: ChangeBrokerContactOnSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateBrokerContactSalesQuoteResponse>;
    public updateBrokerContactSalesQuote(salesQuoteId: string, changeBrokerContactOnSalesQuoteRequest: ChangeBrokerContactOnSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateBrokerContactSalesQuoteResponse>>;
    public updateBrokerContactSalesQuote(salesQuoteId: string, changeBrokerContactOnSalesQuoteRequest: ChangeBrokerContactOnSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateBrokerContactSalesQuoteResponse>>;
    public updateBrokerContactSalesQuote(salesQuoteId: string, changeBrokerContactOnSalesQuoteRequest: ChangeBrokerContactOnSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling updateBrokerContactSalesQuote.');
        }
        if (changeBrokerContactOnSalesQuoteRequest === null || changeBrokerContactOnSalesQuoteRequest === undefined) {
            throw new Error('Required parameter changeBrokerContactOnSalesQuoteRequest was null or undefined when calling updateBrokerContactSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/broker-contacts`;
        return this.httpClient.request<UpdateBrokerContactSalesQuoteResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: changeBrokerContactOnSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Apply changes to an unfinished quotation
     * This endpoint applies changes to an unfinished quotation.
     * @param salesQuoteId ID of the sales quote
     * @param updateSalesQuoteRequest Additional parameters for the customer change
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSalesQuote(salesQuoteId: string, updateSalesQuoteRequest: UpdateSalesQuoteRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UpdateSalesQuoteResponse>;
    public updateSalesQuote(salesQuoteId: string, updateSalesQuoteRequest: UpdateSalesQuoteRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UpdateSalesQuoteResponse>>;
    public updateSalesQuote(salesQuoteId: string, updateSalesQuoteRequest: UpdateSalesQuoteRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UpdateSalesQuoteResponse>>;
    public updateSalesQuote(salesQuoteId: string, updateSalesQuoteRequest: UpdateSalesQuoteRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling updateSalesQuote.');
        }
        if (updateSalesQuoteRequest === null || updateSalesQuoteRequest === undefined) {
            throw new Error('Required parameter updateSalesQuoteRequest was null or undefined when calling updateSalesQuote.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<UpdateSalesQuoteResponse>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: updateSalesQuoteRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Validate sales quote
     * This endpoint marks the sales quote as confirmed (a status as configured on the service) after validating the quote. In case validation fails, warnings are returned and the quote maintains its original status.
     * @param salesQuoteId ID of the sales quote
     * @param validateSalesQuoteRequest Data required to validate a sales quote
     * @param ignoreWarnings Indicates whether warnings should be ignored. If set to true, interactive warnings will be ignored.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public validateSalesQuote(salesQuoteId: string, validateSalesQuoteRequest: ValidateSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ValidateSalesQuoteResponse>;
    public validateSalesQuote(salesQuoteId: string, validateSalesQuoteRequest: ValidateSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ValidateSalesQuoteResponse>>;
    public validateSalesQuote(salesQuoteId: string, validateSalesQuoteRequest: ValidateSalesQuoteRequest, ignoreWarnings?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ValidateSalesQuoteResponse>>;
    public validateSalesQuote(salesQuoteId: string, validateSalesQuoteRequest: ValidateSalesQuoteRequest, ignoreWarnings?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (salesQuoteId === null || salesQuoteId === undefined) {
            throw new Error('Required parameter salesQuoteId was null or undefined when calling validateSalesQuote.');
        }
        if (validateSalesQuoteRequest === null || validateSalesQuoteRequest === undefined) {
            throw new Error('Required parameter validateSalesQuoteRequest was null or undefined when calling validateSalesQuote.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ignoreWarnings !== undefined && ignoreWarnings !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ignoreWarnings, 'ignore_warnings');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Roles) required
        localVarCredential = this.configuration.lookupCredential('Roles');
        if (localVarCredential) {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/sales-quotes/${this.configuration.encodeParam({name: "salesQuoteId", value: salesQuoteId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/validations`;
        return this.httpClient.request<ValidateSalesQuoteResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: validateSalesQuoteRequest,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
